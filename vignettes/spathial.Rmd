---
title: "A short introduction to the _spathial_ Package"
#output: pdf_document
#output: html_document
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spathial Package Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r echo=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=5) 
```

The _spathial_ package contains functions to create a path able to navigate a n-dimensional space.

# Quick start
In this section the most basic steps to run the _spathial_ implementation of the principal path algorithm [1] are shown, through a simple 2d example.

The very first step is the spathial package installation
```{r eval=FALSE}
install.packages("spathial")
```

And its loading:
```{r}
library("spathial")
```

## Step 1: load data
To compute the principal path one assumes that to have an input matrix ```X```. 
Each column of the matrix ```X``` is a feature (e.g. a gene) and each row has a univocal name (e.g. a sample). 
For a supervised solution, one also assumes that the input vector ```X_labels``` is present which contains for each row of ```X``` a description label (e.g. the sample category). Labels must be integer numbers ranging from 1 to the n-th category. Otherwise, the unsupervised solution can be obtained with ```X_labels = NULL```.
For the sake of simplicity, a simple .csv file with 900 samples and 
3 columns (2 + labels) is provided. The following code snippet shows how to load the .csv and how to properly format the data.

```{r}
# Load the dataset with 900 samples
myfile<-system.file("extdata", "2D_constellation.csv", package = "spathial")
data<-read.csv(myfile,as.is=TRUE,header=TRUE,row.names=1)
head(data)
```

```{r}
# Vector X_labels
X_labels <- data$label

# Data Matrix X
X <- data[,1:(ncol(data)-1)]
```

This is how the data matrix ```X``` should look like at this point
```{r}
head(X)
```

The sample labels vector ```X_labels```, assigns categories to each sample,
coherently with rows order in ```X``` 
```{r}
head(X_labels)
```

The following code snippet shows how to plot the data points colored according to ```X_labels```:

```{r fig.cap="_Quick Start example dataset_"}
# Plot the results
colors<-rainbow(length(unique(X_labels)))
colors_labels<-sapply(X_labels,function(x){colors[x]})
plot(X[,1],X[,2],col=colors_labels,pch=as.character(X_labels),
     xlab=colnames(X)[1],ylab=colnames(X)[2])
```

## Step 2: select the boundaries
The fist step to compute the principal path consists in selecting the starting and the ending points. 
The package spathial has the function ```spathialBoundaryIds``` which takes as input the matrix ```X```, 
the corresponding labels ```X_labels``` (or NULL) and the parameters ```mode```, ```from``` and ```to```.

The parameter ```mode``` can assume of one the following values:

* __1__ _(default)_: the user can choose the starting and the ending points directly from the 2D representations of the data points. 
In this case the values of the parameters ```from``` and ```to``` are not considered.
* __2__: the starting point is the centroid of all the data points labelled as the parameter ```from```, while the ending point is the centroid of all the data points labelled as the parameter ```to```. This mode is allowed only when ```X_labels``` is not NULL.
* __3__: the starting point is the data point with the univocal rowname equal to the parameter ```from``` while the ending point is the data point with the univocal rowname equal to the parameter ```to```.

The output of the function ```spathialBoundaryIds``` is a list with the following content:

* __X__: the initial input matrix ```X``` plus the starting and the ending points;   
* __X_labels__: the initial vector ```X_labels``` inclusive of the labels of the starting and the ending points; 
* __boundary_ids__: the rowname of the starting and the ending points.

__N.B.__ The matrix ```X``` and the vector ```X_labels``` change only when ```mode=2``` (the resulting matrix and vector have two additional elements, corresponding to the centroids).

The following code chunks show how to use the function ```spathialBoundaryIds```, with different values of the parameter ```mode```, and how to extract the output:

``` {r eval=FALSE}
# mode=1 (User-selected)
boundary_init <- spathial::spathialBoundaryIds(X, X_labels, mode=1)

```
``` {r}
# mode=2 (From named label centroid to another label centroid)
boundary_init <- spathial::spathialBoundaryIds(X, X_labels, mode=2, from=3, to=6)
```

```
``` {r eval=FALSE}
# mode=3 (From named sample to another named sample)
boundary_init <- spathial::spathialBoundaryIds(X, X_labels, mode=3,
                                               from="sample123", to="sample456")

Once the boundaries are defined, and only in the case of ```mode=2```, the ```X``` and ```X_labels``` objects 
inside the boundary_init object contain extra meta-samples (the boundaries) and thus the original ```X``` and ```X_labels``` need to be updated
accordingly
``` {r}
# Take the output from the variable boundary_init
boundary_ids<-boundary_init$boundary_ids
X<-boundary_init$X
X_labels<-boundary_init$X_labels
```

The following plots the boundaries when ```mode=2```, ```from=3``` and ```to=6```:
``` {r fig.cap="_Quick Start example - boundaries_"}
plot(X[,1],X[,2], col=colors_labels, pch=as.character(X_labels),
     xlab=colnames(X)[1], ylab=colnames(X)[2], main="Boundary points")
points(X[boundary_ids,],pch="x",col="black",cex=4)
```

## Step 3: prefiltering (optional)
The principal path algorithm is intrinsically global. If one is searching for a path which does not involve the whole dataset, one 
can run the function ```spathialPrefiltering```  before the principal path algorithm is applied. 
If one wants to run _spathial_ on the entire dataset, this filtering procedure is not due.

The function ```spathialPrefiltering``` takes as input the matrix ```X``` and the boundaries ```boundary_ids``` which are the result of the function ```spathialBoundaryIds```.

The output of the function ```spathialPrefiltering``` is a list with the following content:

* __mask__: the indexes of the samples to preserve;   
* __boundary_ids_filtered__: the rowname of the starting and the ending points.

The following code shows how to use the function ```spathialPrefiltering``` and how to extract the output. 
The function remove some samples and they are stored in the ```X_garbage``` matrix. The ```mask``` vector contains the samples to be kept.

```{r}
# Prefilter data
filter_res <- spathial::spathialPrefiltering(X, boundary_ids)
mask <- filter_res$mask
boundary_ids <- filter_res$boundary_ids

# Plot the results
boundaries <- X[which(rownames(X) == boundary_ids[1] | rownames(X) == boundary_ids[2]),]
X_garbage <- X[!mask,]
```

The following code shows the results of the prefiltering step, with removed points greyed out:
```{r fig.cap="_Quick Start example - prefiltering_"}
par(mfrow=c(1,2))
plot(X[,1],X[,2], col="black",pch=20,main="Before Filtering",
     xlab=colnames(X)[1],ylab=colnames(X)[2])
points(X[boundary_ids,],pch="x",col="red3",cex=4)
plot(X[,1],X[,2], col="black",pch=20,main="After Filtering",
     xlab=colnames(X)[1],ylab=colnames(X)[2])
points(X[boundary_ids,],pch="x",col="red3",cex=4)
points(X_garbage[,1],X_garbage[,2], col="gray", pch=16)
```

## Step 4: principal path
The function ```spathialWay``` run the principal path algorithm and gives as output the waypoints points. It takes as input the matrix ```X```, the boundaries ```boundary_ids``` and the parameter ```NC```, which is the desired number of waypoints of the resulting principal path. For example, given ```NC=10``` the resulting path will be composed of 10 waypoints plus the starting and the ending points. 

The output of the function ```spathialWay``` is the variable ```spathial_res``` , which contains the coordinates of the waypoints of the principal path;   

The following code shows how to use the function ```spathialWay```, with or without prefiltering, and how to get the output:

```{r results='hide'}
# Compute principal path without prefiltering
NC <- 50
spathial_res_without_filtering <- spathial::spathialWay(X, boundary_ids, NC)
```

```{r results='hide'}
# Compute principal path after prefiltering
X_filtered <- X[mask,]
X_labels_filtered <- X_labels[mask]
NC <- 50
spathial_res_with_filtering <- spathial::spathialWay(X_filtered, boundary_ids, NC)
```

The next subsection shows how to get results from the output object ```spathial_res```.

## Step 5: understanding the results
The package _spathial_ includes three different functions to interpret the output of the principal path algorithm: ```spathialPlot```, ```spathialLables``` and ```spathialStatistics```. The following subsections describe what they do and how to use each of them.

### Plot principal path
The function ```spathialPlot``` plots the principal path together with all the data points (either filtered or not filtered) together 
with the boundaries. This function takes as input the matrix ```X``` (the initial version), the vector ```X_labels``` (or NULL), the boundaries ```boundary_ids```, the output of the principal path algorithm ```spathial_res```, the parameter ```perplexity value``` (default 30) and the parameter ```mask``` which is one of the results of the prefiltering and it is ```NULL``` when the prefiltering is not computed.
When the input matrix ```X``` has more than 2 columns, the function reduce the dimension of the space from N (>2) to 2 using the t-SNE algorithm [2].

The following code shows how to use the function ```spathialPlot``` with the path generated during the previous step (with or without prefiltering):

```{r fig.height=10, fig.cap='_Output of the spathialPlot() function. Filtered samples are marked in grey_'}
par(mfrow=c(2,1))
# Plot principal path with prefiltering - provide a mask
spathial::spathialPlot(X, X_labels, boundary_ids, spathial_res_with_filtering,
                       perplexity_value=30, mask=mask,
                       main="Principal path with prefiltering"
)

# Plot principal path without prefiltering - mask NULL
spathial::spathialPlot(X, X_labels, boundary_ids, spathial_res_without_filtering,
                       perplexity_value=30,                       
                       main="Principal path without prefiltering"
)
```

### Assess path progression
The function ```spathialLabels``` predicts the label for each waypoints of the principal path by detecting the nearest sample [3]. 
This function is available only when ```X_labels != NULL``` and could be particularly useful when one wants to find the breakpoints between one class and the other. 
The function takes as input the matrix ```X``` (which is composed only by the preserved samples if the prefiltering was used), the vector ```X_labels``` and the output object of the principal path algorithm ```spathial_res```. The output are the labels for each waypoint of the principal path.

The following code shows how to use the function ```spathialLabels``` and how to plot the result:

```{r fig.cap='_Quick Start example - path labels across path steps_'}
### Matrix X not filtered
ppath_labels <- spathial::spathialLabels(X, X_labels, spathial_res_with_filtering)
# Plot the results
ppath_labels <- as.vector(ppath_labels)
colors_labels_ppath <- sapply(ppath_labels, function(y){colors[as.integer(y)]})
plot(c(1:length(ppath_labels)), c(ppath_labels), col=colors_labels_ppath,
     pch=as.character(ppath_labels), xlab="Path Step", ylab="Sample Label",
     main="Path progression with prefiltering"
)

### Matrix X filtered
ppath_labels <- spathial::spathialLabels(X, X_labels, spathial_res_without_filtering)
# Plot the results
ppath_labels <- as.vector(ppath_labels)
colors_labels_ppath <- sapply(ppath_labels, function(y){colors[as.integer(y)]})
plot(c(1:length(ppath_labels)), c(ppath_labels), col=colors_labels_ppath,
     pch=as.character(ppath_labels), xlab="Path Step", ylab="Sample Label",
     main="Path progression without prefiltering"
)
```

### Extract principal path associated features
The function ```spathialStatistics``` returns statistics for each feature, based on their relation with the principal path calculated and stored in ```spathial_res```.
In particular, here one wants to understand how much each feature (a coordinate of the N-dimensional space) is correlated with the evolution of the principal path, that is to detect evolutive features. This is a path-centric way to perform feature selection.

For this reason, the output of the function ```spathialStatistics``` is a list that attaches to features a progression score.

* __correlations__: This vector contains the Pearson's correlation coefficients between each feature and the path.
* __rank_scores__: This vector contains the ranks of associations between the n features and the path (1 being the most positively correlated, and n the most negatively correlated).

The following code shows how to use the function ```spathialStatistics``` and to extract the correlation-based association between features and the path.

```{r message="hide"}
# Calculate Association Statistics for each feature in the path
statistics <- spathial::spathialStatistics(spathial_res_with_filtering)

# Extract Pearson correlation coefficients between features and path
statistics$correlations

# Calculate Association Statistics for each feature in the path
statistics <- spathial::spathialStatistics(spathial_res_without_filtering)

# Extract Pearson correlation coefficients between features and path
statistics$correlations
```

# A slightly more complex example
In this section it is shown a higher-dimensional example, with 100 features. In this case the input matrix ```X``` is a reduced version of the TCGA Liver Cancer RNA-Seq dataset which is composed only by the 100 features (gene expression profiles, RPM-normalized) with the highest variance across the dataset. The vector ```X_labels``` contains the information about the samples. In particular, the label is 1 for tumor samples, and 2 for normal samples, collected in the same dataset.

In this case, the aim of the example is to navigate the space from the centroid of the normal tissue samples (label 2) to the centroid of the tumor samples (label 1) in order to gradually morphing from one histological state to the other.

The prefiltering won't be executed since one is searching for a global solution.

The following code blocks shows how to compute the principal path algorithm. First, one loads the data from a CSV file containing RPM-normalized gene expression data:

```{r}
# Load data
myfile<-system.file("extdata", "liver_tcga_example1.csv", package = "spathial")
data<-read.csv(myfile,as.is=TRUE,header=TRUE,row.names=1)
data[1:4,1:5]
```

Then one transforms it into two objects: the numeric gene expression profiles (```X```) and the associations between samples and samples category (```X_labels```), where 1 indicates a tumor sample, and 2 a normal tissue sample.
```{r}
X <- data[,1:(ncol(data)-1)]
X_labels <- data[,"Category"]
X[1:4,1:5]
```
```{r results="hide"}
# Choose the starting and the ending points
boundary_init <- spathial::spathialBoundaryIds(X, X_labels, mode=2, from=2, to=1)
# Alternative, mode 3: 
# from="TCGA-DD-A39W-11A-11R-A213-07", to="TCGA-G3-AAV2-01A-11R-A37K-07"
boundary_ids <- boundary_init$boundary_ids
X <- boundary_init$X
X_labels <- boundary_init$X_labels

# run spathial
NC <- 50
spathial_res <- spathial::spathialWay(X, boundary_ids, NC)
```
In order to visualize the multi-dimensional dataset on two dimensions, one performs a TSNE analysis on it [2].

```{r fig.cap="_Principal Path across the TCGA Liver Cancer dataset_"}
# Plot the path in 2D using Rtsne
spathial::spathialPlot(X, X_labels, boundary_ids, spathial_res,
                       perplexity_value=30)

```

```{r fig.cap='_Liver Cancer example - path labels across path steps_'}
# Labels for each waypoint with knn
ppath_labels <- spathial::spathialLabels(X, X_labels, spathial_res)
# Plot the results
ppath_labels <- as.vector(ppath_labels)
colors_labels_ppath <- sapply(ppath_labels, function(y){colors[as.integer(y)]})
plot(c(1:length(ppath_labels)), c(ppath_labels), col=colors_labels_ppath,
     pch=as.character(ppath_labels), xlab="Path Step", ylab="Sample Label",
     main="Path progression"
)
```

Then one can quickly extract the gene expression profiles most correlated with the path:
```{r}
# Correlation along the path
statistics<-spathialStatistics(spathial_res)
```
In this case, the statistic is particularly interesting, as it shows the most associated the functional genes to the transition between normal and tumor liver tissues. 
In fact, it contains information about the correlation between each feature (genes) and a vector from 1 to NC+2 (where NC is the number of waypoints)
that represents the progression along the path.  This helps finding the genes particularly involved with the evolution from the healthy to the unhealthy state. The following code highlights the 10 most positively and most negatively associated genes to the normal-tumor path progression:
```{r}
singlepath_correlations<-statistics$correlations
top_positive_correlations<-sort(singlepath_correlations,decreasing=TRUE)[1:10]
top_positive_correlations
top_negative_correlations<-sort(singlepath_correlations,decreasing=FALSE)[1:10]
top_negative_correlations
```

# References

[1] M. J. Ferrarotti, W. Rocchia, and S. Decherchi, “Finding Principal Pathsin  Data  Space,”  IEEE Transactions  on  Neural Networks  and  LearningSystems, vol. 30, pp. 2449–2462, Aug. 2019

[2]  L. van der Maaten and G. Hinton, “Viualizing data using t-SNE,” Journal of Machine Learning Research, vol. 9, pp. 2579–2605, Nov. 2008.

[3] T. Cover  and  P.  Hart,  “Nearest  neighbor  pattern  classification,”  IEEE Transactions on Information Theory, vol. 13, pp. 21–27, Jan. 1967.
